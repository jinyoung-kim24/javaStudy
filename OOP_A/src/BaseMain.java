
public class BaseMain {

	public static void main(String[] args) {
		// 진법(radix)은 기준수 base의 나머지들로 자리수를 표현되는 수체계
		// 디지털 1, 0 상태밖에 없음.. 논리상태를 2진법표현...
		//int a = 10;  // 십진법으로 표현된 10 수치값
		int a = 0x0A; // 0~15 0~9,A~F 대응.. 16진법 
		//int b = 9; 
		int b = 0x09;
		// 니블 0b0000 ~ 0b1111 ==> 0x0 ~ 0xF
		int a2 = 0b00001010; // 10 = 8 + 2 
						   // = 2^3 + 0*^2 + 2^1 + 0*^0 
						   //     1    0      1     0
		int b2 = 0b00001001;
		
		int c = -9;
		//int c2 = 0b00001001;  // 9?
		//int c2 = 0b10001001;  // 137?
		// 비트로 정수를 표현했을때, 가령 int인 32비트 정수표현에서는
		// signed 부호를 가지기 위해 최상위 32번째 (왼쪽) 비트를 부호비트 정함
		// 1이면 음수, 0이면 양수. 
		int c2 = 0b10000000_00000000_00000000_00001001; 
				// -2147483639 
		System.out.println(c2);
		
		// 음의 십진수 -9를 이진법 음수로 표현하기
		// byte의 경우..
		// 1. -9와 크기가 같은 양수 9의 이진표현을 만든다.
		// 00001001 = 2^3 + 2^1 
		// 2. 이 이진 표현에 최상위 부호 비트를 1로 변경
		// 10001001 = 2^3 + 2^1
		// 3. 이제 부호비트 제외한 나머지 비트들(byte의 경우 하위 7개 비트)을
		// 모두 비트~(역으로 변경) 1 -> 0, 0 -> 1 변경처리. 
		// (1의 보수; one's complement)
		// 11110110
		// 4. 여기에 1을 더한다. 
		// 11110110 + 00000001 = 11110111
		// 즉, -9 십진수는 이진법으로 0b11110111으로 표현됨.
		System.out.println((byte)0b11110111);
		//byte bb = 127;
		byte bb = (byte)128;
		System.out.println(bb);
		/*
		 -2147483639
		 -9 => 0b11110111
		 -128
		 -1 => 0b11111111
 		 */
		
		byte bbb = (byte)0b11110111; 
		// 음의 이진수를 십진법으로 표현하기.. 
		// 1. 1의 보수를 취한다. 
		// 11110111 => 00001000 
		// 2. 여기에 1을 한 번 더한다. (2의 보수)
		// 00001000 + 00000001 = 00001001
		// 3. 이 이진법을 십진법으로 연산 (거듭제곱)
		// 00001001 = 2^3 + 2^0 = 8 + 1 = 9
		// 4. 이 십진법값에 - 음의 부호 붙임. 
		// -9
	}

}
